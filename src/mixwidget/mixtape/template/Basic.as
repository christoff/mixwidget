/* The contents of this file are subject to the Common Public Attribution * License Version 1.0. (the "License"); you may not use this file except in * compliance with the License. You may obtain a copy of the License at * http://mixwidget.com/license. The License is based on the Mozilla Public * License Version 1.1, but Sections 14 and 15 have been added to cover use of * software over a computer network and provide for limited attribution for the * Original Developer. In addition, Exhibit A has been modified to be consistent * with Exhibit B. *  * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for * the specific language governing rights and limitations under the License. *  * The Original Code is Mixwidget. *  * The Original Developers are Michael Christoff & Radley Marx.  The Initial  * Developers of the Original Code are Michael Christoff & Radley Marx. */package mixwidget.mixtape.template{	import flash.display.Bitmap;	import flash.display.Loader;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.*;	import flash.filters.DropShadowFilter;	import flash.geom.ColorTransform;	import flash.net.URLRequest;	import flash.system.LoaderContext;	import flash.system.Security;	import flash.text.*;		import mixwidget.media.AudioEvent;	import mixwidget.media.FlashAudioPlayer;	import mixwidget.mixtape.Global;	import mixwidget.mixtape.events.MixtapeEvent;	import mixwidget.util.Util;		//import XmlLoader;		public class Basic extends MovieClip	{		//XSPF namespace stuff    namespace xspf = "http://xspf.org/ns/0/";    use namespace xspf;				public var widget:XML;		public var playlist:XML;				public var txt:TextField;		public var artistText:TextLabel;		public var trackText:TextLabel;				private var shadowFilter:DropShadowFilter;		private var myColor:ColorTransform;				public var cassette:MovieClip;		public var skinHolder:Sprite;		public var imageHolder:Sprite;		public var skinMask:Sprite;		public var imageMask:Sprite;		public var bodyMask:Sprite;						public var gloss:Sprite;		public var outlines:Sprite;		public var audio:*;		public var editable:Boolean = false;		public var playable:Boolean = false;				private var isImageReady:Boolean = false;		private var isSkinReady:Boolean = false;						private var skin:*;		private var skinLoader:Loader;		private var skinURL:URLRequest;		private var context:LoaderContext;		private var skinSource:String;						private var userImage:*;		private var userImageLoader:Loader;		private var userImageURL:URLRequest;		private var userImageSource:String;				public var templateRoot:String = "";				private var totalTracks:Number;		private var trackWidth:Number;		private var currentTrackNum:Number = 0;				private var player:FlashAudioPlayer;				private var image_url:String;		private var skin_url:String;				public function Basic(image_url:String=null, skin_url:String=null)		{ 		  Util.d();					Security.allowDomain("*");						this.image_url = image_url;			this.skin_url = skin_url;						context = new LoaderContext();			context.checkPolicyFile = true;						myColor = new ColorTransform();		}				public function init():void		{			Util.d(); 			Util.d('before h:' + this.height, 1);						initFilters();		}			  public function initPlayer(p:FlashAudioPlayer):void	  {	  	Util.d();	  	this.player = p;	  	if(playable){        player.addEventListener(AudioEvent.PLAYING, onAudioPlay);        player.addEventListener(AudioEvent.RESUMING, onAudioPlay);        player.addEventListener(AudioEvent.PAUSED, onAudioPause);        player.addEventListener(AudioEvent.STOPPED, onAudioPause);        player.addEventListener(AudioEvent.TRACK_COMPLETE, onAudioComplete);        player.addEventListener(AudioEvent.STATUS, updateStatus);      }	  }				public function config():void		{ 		  Util.d();			setViews();		}				public function applyPlaylist(src:XML):void		{			Util.d();			playlist = src;					totalTracks = playlist.trackList.track.length();			Util.d('totalTracks: ' + totalTracks, 1);			var maxMagWidth:Number = (10 + Math.min(15, totalTracks)) / 10;						if (totalTracks > 0) 	{ 							trackWidth = (maxMagWidth - 1) / totalTracks;				cassette.magTape1.scaleX = cassette.magTape1.scaleY = (1 + (totalTracks * trackWidth)).toFixed(4);				cassette.magTape2.scaleX = cassette.magTape2.scaleY = 1;							} else											{				trackWidth = 0;				cassette.magTape1.scaleX = cassette.magTape1.scaleY = 1;				cassette.magTape2.scaleX = cassette.magTape2.scaleY = 1;							}		}				// VIEWS *************************************************************************************				public function setViews():void		{ 			Util.d();			isImageReady 	= false;			isSkinReady 	= false;			addEventListener(Event.ENTER_FRAME, loadCompleteCheck);						if (widget.properties.hasOwnProperty("image")|| this.image_url) { loadUserImage(); }			else                                           { removeUserImage(); }							if (widget.skin.hasOwnProperty("@name") || this.skin_url) 	{ loadTapeSkin(); }			else 																		                    { removeTapeSkin(); }					}				private function loadCompleteCheck(event:Event):void		{			if (isImageReady && isSkinReady)			{				Util.d('Basic: loadCompleteCheck - image & skin ready');				removeEventListener(Event.ENTER_FRAME, loadCompleteCheck);				applyViews();			}		}				private function applyViews():void		{ 		  Util.d();			setTextFormat();			setText(widget.title, widget.creator);			setShadow();			setGloss();			setOutlines();			setColor("frameColor");			setColor("bodyColor");			setColor("gearboxColor");			setColor("gearColor");			setColor("threaderColor");						var imgList:XMLList = widget.properties.image.(@type == "orig");						if( (widget.properties.image.(@type == "orig") as XMLList).length() > 0  && !this.image_url){				imageHolder.scaleX = widget.properties.image.(@type == "orig").@scale / 100;	      imageHolder.scaleY = widget.properties.image.(@type == "orig").@scale / 100;	      imageHolder.x = widget.properties.image.(@type == "orig").@x;	      imageHolder.y = widget.properties.image.(@type == "orig").@y;	      setImageMask(widget.properties.image.(@type == "orig").@mask);			}else{				imageHolder.scaleX = 1;				imageHolder.scaleY = 1;				imageHolder.x = 0;				imageHolder.y = 0;				setImageMask('full');			}												Util.d("*basic complete*");						this.dispatchEvent(new MixtapeEvent(MixtapeEvent.TEMPLATE_LOAD_COMPLETE));					}				public function setTextFormat():void		{			trackText.configFormat(widget.skin.properties.text);			artistText.configFormat(widget.skin.properties.text);			trackText.configLabel(widget.skin.properties.trackText);			artistText.configLabel(widget.skin.properties.artistText);		}				public function setText(title:String="", creator:String=""):void		{ 			trackText.txt.htmlText = title;			artistText.txt.htmlText = creator;		}				// VIEW *************************************************************************************						public function setColor(value:String):void		{			Util.d();			switch(value) {								case("gearColor") 	: setGearColor(); 						break;				default							: setItemColor(value);				break;			}		}				public function setShadow():void 		{			Util.d();			shadowFilter.strength  	= widget.skin.properties.shadow/100;			this.cassette.filters   = [shadowFilter];		}								public function setGloss():void		{			Util.d("gloss = " + widget.skin.properties.gloss)			this.gloss.alpha = widget.skin.properties.gloss/100;		}						public function setOutlines():void 		{			Util.d();			this.outlines.alpha = widget.skin.properties.outlines/100;		}				public function setItemColor(item:String):void		{			Util.d(item);			myColor.color = Number("0x"+widget.skin.properties[item]);			this.cassette[item].transform.colorTransform = myColor;		}				public function setGearColor():void		{ 			Util.d();			myColor.color = Number("0x"+widget.skin.properties.gearColor);			this.cassette.gear1.gear.transform.colorTransform = myColor;			this.cassette.gear2.gear.transform.colorTransform = myColor;		}				private function initFilters():void		{ 			Util.d();			shadowFilter = new DropShadowFilter();			shadowFilter.distance = 10;			shadowFilter.angle = 25;			shadowFilter.quality = 3; // 1-3, 3 is "high"; can go has high as 15, but takes longer to render			shadowFilter.strength = 1;			this.cassette.filters = [shadowFilter];		}				//IMAGE *************************************************************************************				private function removeTapeSkin():void		{ 		  Util.d();					skinHolder.visible = false;			isSkinReady = true;		}				private function removeUserImage():void		{ 		  Util.d();					imageHolder.visible = false;			isImageReady = true;		}				public function loadTapeSkin():void		{ 		  Util.d();			var list:XML  = widget.skin.resources.image.(@type == "orig")[0]; 			var src:String = "";			if(widget.@version == "2.0"){			  src = (this.skin_url && this.skin_url != "") 			  ? this.skin_url : Global.BASE + "skin.jpg";			}else{				src = list.@src;			}						if (src != skinSource)			{			  this.dispatchEvent(new Event("imageLoadStart"));			  isSkinReady = false;				skinSource = src;				var request:URLRequest = new URLRequest(skinSource);				//skinLoader.load(urlRequest, context);			  var loader:Loader = new Loader();			  loader.load(request, context);			  loader.contentLoaderInfo.addEventListener(Event.COMPLETE, skinLoaded);				loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, skinLoadError);			}			else { isSkinReady = true; };		}		 		private function skinLoaded(event:Event):void		{			Util.d();						event.target.content.width = cassette.width;			event.target.content.height = cassette.height;			try{			  skinHolder.removeChildAt(0);			}catch(error:Error){			  Util.d("skinLoaded: no previous skin to remove");			}      skinHolder.addChild(event.target.content);			skinHolder.visible = true;			skinHolder.cacheAsBitmap = true;			isSkinReady = true;			this.dispatchEvent(new Event("imageLoadComplete"));		}				private function skinLoadError(event:IOErrorEvent):void		{			Util.e(event.text);			isSkinReady = true;			this.dispatchEvent(new Event("imageLoadComplete"));		}				public function loadUserImage():void		{ 		  Util.d();			var list:XML  = widget.resources.image.(@type == "orig")[0]; // find image.@type = "orig"			// var src:String = (widget.@version == "2.0") ? "image.jpg" : list.@src;						var src:String = "";      if(widget.@version == "2.0"){        src = (this.image_url && this.image_url != "") ?           this.image_url : Global.BASE + "image.jpg";      }else{        src = list.@src;      }						if (src != userImageSource)			{			  this.dispatchEvent(new Event("imageLoadStart"));			  isImageReady = false;				userImageSource = src;				var request:URLRequest = new URLRequest(templateRoot + userImageSource);				var loader:Loader = new Loader();        loader.load(request, context);        loader.contentLoaderInfo.addEventListener(Event.COMPLETE, userImageLoaded);				loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, userImageLoadError);			}			else			{				isImageReady = true;			};		}				private function userImageLoadError(event:IOErrorEvent):void		{			Util.d();			isImageReady = true;			this.dispatchEvent(new Event("imageLoadComplete"));		}		 		private function userImageLoaded(event:Event):void		{			Util.d();			var list:XMLList  = widget.properties.image.(@type == "orig"); // find image.@type = "orig"      try{        imageHolder.removeChildAt(0);      }catch(error:Error){        Util.d("userImageLoaded: no previous user image to remove");      }						// for that smooth look and feel....			var bitmap:Bitmap = (event.target.content as Bitmap);			bitmap.smoothing = true;			      imageHolder.addChild(bitmap);      			imageHolder.visible = true;			imageHolder.cacheAsBitmap = true;			isImageReady = true;			this.dispatchEvent(new Event("imageLoadComplete"));		}				public function setImageMask(src:String):void		{			Util.d();			if (src == "body")		{ imageHolder.mask = bodyMask; }			else									{ imageHolder.mask = imageMask; };		}						// AUDIO *************************************************************************************				public function onAudioPlay(event:Event):void		{			startGears();		}				public function onAudioPause(event:Event):void		{			stopGears();		}				public function onAudioComplete(event:Event):void		{			stopGears();		}		  private function updateStatus(event:AudioEvent):void  {					  setText(event.track.title, event.track.creator);						  currentTrackNum     = event.status.currentTrackNum;		  totalTracks         = event.status.totalTracks;		  		  var position:Number   = event.status.position;		  var length:Number     = Math.max(1, event.status.duration);		  		  if(position == 0 || length == 0) {		    Util.d(" Error: Track or leng = 0, skipping spool update");		    return;		  }		  		  var remainingTracks:Number = totalTracks - currentTrackNum;		  var trackPortion:Number    = position/length;		  		  var mag1tracks:Number   = remainingTracks - trackPortion;		  var mag2tracks:Number   = currentTrackNum + trackPortion;				  		  cassette.magTape1.scaleX = cassette.magTape1.scaleY = (1 + (mag1tracks * trackWidth)).toFixed(4);		  cassette.magTape2.scaleX = cassette.magTape2.scaleY = (1 + (mag2tracks * trackWidth)).toFixed(4);							//cassette.gear1.spinRate = (3 * (1 / cassette.magTape1.scaleX)).toFixed(1);						// Util.d("cassette.gear1.spinRate = " + cassette.gear1.spinRate);			// Util.d("cassette.magTape1.scaleX = " + cassette.magTape1.scaleX);			// Util.d("cassette.magTape2.scaleX = " + cassette.magTape2.scaleX);    }    				private function startGears():void		{			cassette.gear1.startRotation();			cassette.gear2.startRotation();		}				private function stopGears():void		{			cassette.gear1.stopRotation();			cassette.gear2.stopRotation();		}			}}