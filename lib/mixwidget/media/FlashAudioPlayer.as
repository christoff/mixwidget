/* The contents of this file are subject to the Common Public Attribution * License Version 1.0. (the "License"); you may not use this file except in * compliance with the License. You may obtain a copy of the License at * http://mixwidget.com/license. The License is based on the Mozilla Public * License Version 1.1, but Sections 14 and 15 have been added to cover use of * software over a computer network and provide for limited attribution for the * Original Developer. In addition, Exhibit A has been modified to be consistent * with Exhibit B. *  * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for * the specific language governing rights and limitations under the License. *  * The Original Code is Mixwidget. *  * The Original Developers are Michael Christoff & Radley Marx.  The Initial  * Developers of the Original Code are Michael Christoff & Radley Marx. */package mixwidget.media{  import flash.display.*;  import flash.events.*;  import flash.geom.Rectangle;  import flash.text.TextField;    public class FlashAudioPlayer extends AudioPlayer  {    private var _lastClick:String = "";		public const SCRUB_LAG:uint = 5000;				private var scrubber:MovieClip;		private var volumeControl:MovieClip;		private var background:MovieClip;				private var soundBtn:SimpleButton;				public var time_txt:TextField;				private var cachedVolume:Number = 0;				private var press:Boolean = false;				private var _volume:Number = .7;        public function FlashAudioPlayer(statusInterval:uint=200, volume:Number = 0.7, autonext:Boolean = true, repeat:Boolean = false)    {      super(statusInterval, volume, autonext, repeat);      this.addEventListener(AudioEvent.DEAD_TRACK, onDeadTrack);    }        [Bindable("volumeChanged")]    override public function get volume():Number    {       return _volume;    }        override public function set volume(newVolume:Number):void{      _volume = newVolume;            checkForPlayability(_volume);      dispatchEvent(new Event("volumeChanged"));    }        public function initButtons(playBtn:SimpleButton, pauseBtn:SimpleButton, prevBtn:SimpleButton, nextBtn:SimpleButton):void    {      playBtn.addEventListener(MouseEvent.CLICK, onPlayButtonClick);      pauseBtn.addEventListener(MouseEvent.CLICK, onPauseClick);      prevBtn.addEventListener(MouseEvent.CLICK, onPrevClick);      nextBtn.addEventListener(MouseEvent.CLICK, onNextClick);    }				public function unInitButtons(playBtn:SimpleButton, pauseBtn:SimpleButton, prevBtn:SimpleButton, nextBtn:SimpleButton):void    {      playBtn.removeEventListener(MouseEvent.CLICK, onPlayButtonClick);      pauseBtn.removeEventListener(MouseEvent.CLICK, onPauseClick);      prevBtn.removeEventListener(MouseEvent.CLICK, onPrevClick);      nextBtn.removeEventListener(MouseEvent.CLICK, onNextClick);    }				public function initScrubber(scrb:MovieClip, time:TextField):void    {			//trace("\r\r*********\r\r\rWidgetConfig.player.initScrubber("+src+")");			scrubber = scrb;			time_txt = time;						//scrubber.btn.visible = false;						scrubber.btn.mouseEnabled 	= true;			scrubber.btn.buttonMode 		= true;			scrubber.btn.useHandCursor 	= true;						scrubber.loadBar.mouseEnabled 	= true;			scrubber.loadBar.buttonMode 		= true;			scrubber.loadBar.useHandCursor 	= true;						scrubber.progBar.mouseEnabled = false;			scrubber.progBar.mouseChildren = false;						scrubber.btn.addEventListener(MouseEvent.MOUSE_DOWN, onScrubPress);			scrubber.btn.addEventListener(MouseEvent.MOUSE_UP, onScrubRelease);			scrubber.loadBar.addEventListener(MouseEvent.CLICK, onScrubClick);    }        public function initVolumeControl(src:MovieClip, btn:SimpleButton):void		{			volumeControl = src;			soundBtn			= btn;						volumeControl.btn.y = 0 - (((volume+.08) * 24) + 14);			volumeControl.btn.mouseEnabled = true;			volumeControl.btn.buttonMode = true;			volumeControl.btn.useHandCursor = true;						volumeControl.volBar.mouseEnabled = false;			volumeControl.volBar.mouseChildren = false;						volumeControl.btn.addEventListener(MouseEvent.MOUSE_DOWN, onVolumePress);			volumeControl.btn.addEventListener(MouseEvent.MOUSE_UP, onVolumeRelease);						volumeControl.volBar.addEventListener(MouseEvent.CLICK, onVolumeClick);						soundBtn.addEventListener(MouseEvent.CLICK, onSoundBtnClick);    }				private function onSoundBtnClick(event:MouseEvent):void		{			if (volume > 0) {				cachedVolume = volume;				volume = 0;			}			else			{				volume = cachedVolume;			}						volumeControl.btn.y = 0 - (((volume+.08) * 24) + 14);		}    public function initFirstPlayButton(firstPlayBtn:SimpleButton):void    {			//trace("\rWidgetConfig.player.initFirstPlayButton("+firstPlayBtn+")");			//trace("this.state = " + this.state);      firstPlayBtn.addEventListener(MouseEvent.CLICK, onPlayButtonClick);    }        private function onPlayButtonClick(event:MouseEvent):void    {			//trace("onPlayButtonClick()");			//trace("this.state = " + this.state);			//trace("this.tracksLoaded = " + this.tracksLoaded);				      if(this.state != AudioPlayer.PLAYING && this.state != AudioPlayer.PAUSED && this.tracksLoaded){        this.play();      }else if(this.state == AudioPlayer.PAUSED) {        this.resume();      }    }        public function onPauseClick(event:MouseEvent):void    {			//trace("onPauseClick()");			onPause();    }				public function onPause():void		{						//trace("this.state = " + this.state);      if(this.state == AudioPlayer.PLAYING) {        this.pause();      }		}        private function onPrevClick(event:MouseEvent):void     {       this.prev();       _lastClick = AudioEvent.PREV_TRACK;    }        private function onNextClick(event:MouseEvent):void     {       this.next();       _lastClick = AudioEvent.NEXT_TRACK;     }        private function onDeadTrack(event:AudioEvent):void {       event.track.@isDead = true;      event.track.@isPlaying = false;      //todo: stop circle!       if(!this.areAllDead() && this.state != AudioPlayer.PAUSED){  //todo: move this to audio player        (_lastClick != AudioEvent.PREV_TRACK) ? this.next() :this.prev();      }else{        //trace("* All tracks are dead in current playlist, stopping.");				stopAll();      }    }		public function stopAll():void		{      this.stop();			this.dispatchAudioEvent(AudioEvent.STATUS, status);		}						private function onScrubPress(event:MouseEvent):void{						//trace("onScrubPress");			press = true;			this.scrubStart();			scrubber.stage.addEventListener(MouseEvent.MOUSE_MOVE, onScrubDrag);			scrubber.btn.startDrag(false, new Rectangle(7, -3.5, (scrubber.loadBar.width-(scrubber.btn.width/2)), 0));						scrubber.stage.addEventListener(MouseEvent.MOUSE_UP, onScrubRelease);		}				private function onScrubDrag(event:MouseEvent):void    {			//trace("onScrubDrag");			updateScrubPostition();			event.updateAfterEvent();    }				private function updateScrubPostition():void{						var scrubValue:Number;						if ( (scrubber.btn.x - (scrubber.btn.width/2)) <= 0)			{ 				scrubValue = 0;			}			else			{				scrubValue = ( (scrubber.btn.x - (scrubber.btn.width/2)) / (scrubber.loadBar.width-scrubber.btn.width)  ) * this.status.length;			}						if(!press) this.scrubStart();      if(this.status.length < scrubValue){        status.position = (this.status.length > 0 ) ? this.status.length  : 0;      }else{        status.position = scrubValue;      }						this.scrubMove(status.position);			      this.dispatchAudioEvent(AudioEvent.STATUS, status.copy());		}				private function onScrubRelease(event:Event):void    {						scrubber.btn.stopDrag();			scrubber.stage.removeEventListener(MouseEvent.MOUSE_MOVE, onScrubDrag);			scrubber.stage.removeEventListener(MouseEvent.MOUSE_UP, onScrubRelease);			updateScrubPostition();						press = false;			this.scrubEnd(status.position);    }				private function onScrubClick(event:MouseEvent):void		{			scrubber.btn.x = scrubber.btn.parent.mouseX;			press = true;			this.scrubStart();			updateScrubPostition();			press = false;			this.scrubEnd(status.position);					}				private function onVolumePress(event:MouseEvent):void{						//trace("onVolumePress");			//press = true;			//this.scrubStart();			volumeControl.stage.addEventListener(MouseEvent.MOUSE_MOVE, onVolumeDrag);			volumeControl.btn.startDrag(false, new Rectangle(9, -40, 0, 24));						volumeControl.stage.addEventListener(MouseEvent.MOUSE_UP, onVolumeRelease);						//stage.addEventListener(MouseEvent.MOUSE_UP, onScrubDrag);					}				private function onVolumeDrag(event:MouseEvent):void{						//trace("onVolumeDrag");			updateVolumePostition();			event.updateAfterEvent();					}				private function updateVolumePostition():void		{			var volumeValue:Number = Number(((0 - (volumeControl.btn.y + 14)) / 24).toFixed(2)) -.08 ;			      volume = volumeValue;		}				private function onVolumeRelease(event:MouseEvent):void{						volumeControl.btn.stopDrag();			volumeControl.stage.removeEventListener(MouseEvent.MOUSE_MOVE, onScrubDrag);			volumeControl.stage.removeEventListener(MouseEvent.MOUSE_UP, onVolumeRelease);			updateVolumePostition();		}				private function onVolumeClick(event:MouseEvent):void{			volumeControl.btn.y = event.target.parent.mouseY;			var volumeValue:Number = Number(((0 - (volumeControl.btn.y + 14)) / 24).toFixed(2)) -.08 ;      volume = volumeValue;		}  }}