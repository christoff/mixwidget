/* The contents of this file are subject to the Common Public Attribution * License Version 1.0. (the "License"); you may not use this file except in * compliance with the License. You may obtain a copy of the License at * http://mixwidget.com/license. The License is based on the Mozilla Public * License Version 1.1, but Sections 14 and 15 have been added to cover use of * software over a computer network and provide for limited attribution for the * Original Developer. In addition, Exhibit A has been modified to be consistent * with Exhibit B. *  * Software distributed under the License is distributed on an "AS IS" basis, * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for * the specific language governing rights and limitations under the License. *  * The Original Code is Mixwidget. *  * The Original Developers are Michael Christoff & Radley Marx.  The Initial  * Developers of the Original Code are Michael Christoff & Radley Marx. */package mixwidget.media{  import flash.events.Event;  import flash.events.EventDispatcher;  import flash.events.IOErrorEvent;  import flash.events.SecurityErrorEvent;  import flash.events.TimerEvent;  import flash.media.Sound;  import flash.media.SoundChannel;  import flash.media.SoundTransform;  import flash.net.URLLoader;  import flash.net.URLRequest;  import flash.utils.Timer;    import mixwidget.util.Util;    public class AudioPlayer extends EventDispatcher  {    //XSPF namespace stuff    namespace xspf = "http://xspf.org/ns/0/";    use namespace xspf;        protected var VOLUME:Number;    protected var POSITION_UPDATE_INTERVAL:uint = 1000;    protected var AUTONEXT:Boolean;    protected var REPEAT:Boolean;        public static const PLAYING:String = "play";    public static const PAUSED:String = "pause";    public static const STOPPED:String = "stop";    public static const SCRUBBING:String = "scrub";    public static const SCRUBBING_PAUSED:String = "scrub pause";        private var _sound:Sound;    private var _soundChannel:SoundChannel    private var _currentPosition:Number;    private var _positionUpdateTimer:Timer;    private var _currentTrackNum:Number = -1;    private var _tracks:XMLList    private var _state:String = STOPPED;    private var _status:AudioStatus;        public function AudioPlayer(statusInterval:uint=200, volume:Number = .7, autonext:Boolean = true, repeat:Boolean = false)    {       _currentPosition = 0;       POSITION_UPDATE_INTERVAL = statusInterval;       //VOLUME = volume;       AUTONEXT = autonext;       REPEAT = repeat;              VOLUME = volume;       addListenters();    }        private function addListenters():void    {    	this.addEventListener(AudioEvent.PLAY_TRACK, onPlayTrack);    }        private function onPlayTrack(event:AudioEvent):void    {    	if(this.currentTrackNum != event.track_num){    		this.play(event.track_num);    	}    }				public function resetPlayer():void		{			 _currentPosition = 0;			 _currentTrackNum	= 0;		}    //    public function loadPlaylist(playlist:XML):void//    {//      _playlist = playlist;//    }        public function loadTracks(tracks:XMLList):void    {      _tracks = tracks;    }        public function stop():void    {      _currentPosition = 0;      _soundChannel.stop();      this.stopPositionTimer();			_state = AudioPlayer.STOPPED;			this.dispatchAudioEvent(AudioEvent.STOPPED);            try{      	//if(_sound.url.indexOf("http://www.seeqpod.com/") > -1 ){      		_sound.close();      	//}      }catch(e:Error){        Util.d("Already stopped: " + e.message);      }          }        public function play(trackNum:int = 0):void    {			Util.d("this.isPlayable = " + this.isPlayable);      if(this.isPlayable) this.stop();      //send loading event      _currentTrackNum = trackNum;      var track:XML = this.getTrack(trackNum);      var location:String = "";						Util.d("_currentTrackNum = " + _currentTrackNum);			Util.d("track = " + track);			Util.d("location = " + track.location);			       location = track.location;       _sound = load(location);            //play current song or unpause      _soundChannel = _sound.play(_currentPosition);      checkForPlayability(volume);      _soundChannel.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);            startPositionTimer();      _state = AudioPlayer.PLAYING;      this.dispatchAudioEvent(AudioEvent.PLAYING);    }        public function resume(sendEvent:Boolean = true):void    {      if(!this.isPlayable) {        //TODO: throw exception        Util.d("Error: AudioPlayer is not playable, SoundPlayer not initialized.");        return;      }else if(_state == AudioPlayer.PLAYING){        Util.d("Error: track is playing");        return;      }          _soundChannel = _sound.play(_currentPosition);      checkForPlayability(volume);      //this.volume = Config.global.volume;      _soundChannel.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);            this.startPositionTimer();      if(sendEvent) {        _state = AudioPlayer.PLAYING;        this.dispatchAudioEvent(AudioEvent.RESUMING);      }    }        public function pause(sendEvent:Boolean = true):void    {      _currentPosition = _soundChannel.position;      _soundChannel.stop();      //this.stopPositionTimer();            if(sendEvent) {        this.dispatchAudioEvent(AudioEvent.PAUSED);        _state = AudioPlayer.PAUSED;      }    }        public function next(roundRobin:Boolean=false):void    {      if(!this.canPlayNext && !roundRobin) {      	this.stop();        return;      }            this.dispatchAudioEvent(AudioEvent.STOPPED);      _currentTrackNum = this.nextTrackNum;      this.play(_currentTrackNum);      this.dispatchAudioEvent(AudioEvent.NEXT_TRACK);    }        public function prev(roundRobin:Boolean=false):void    {      if(!this.canPlayPrev && !roundRobin) {      	this.stop();        return;      }            this.dispatchAudioEvent(AudioEvent.STOPPED);      _currentTrackNum = this.prevTrackNum;      this.play(_currentTrackNum);      this.dispatchAudioEvent(AudioEvent.NEXT_TRACK);    }        public function scrubStart():void    {      if(_state == AudioPlayer.PAUSED){        _state = AudioPlayer.SCRUBBING_PAUSED;      }else{        _state = AudioPlayer.SCRUBBING;        this.pause(false);      }			this.dispatchAudioEvent(AudioEvent.SCRUB_START);    }				public function scrubMove(newPosition:Number):void		{			_currentPosition = newPosition;		}        public function scrubEnd(newPosition:Number):void    {      _currentPosition = newPosition;      if(_state == AudioPlayer.SCRUBBING){        this.resume(false);        _state = AudioPlayer.PLAYING;      }else{        _state = AudioPlayer.PAUSED;      }      this.dispatchAudioEvent(AudioEvent.SCRUB_FINISH);    }            public function get volume():Number    {       return VOLUME;    }        public function set volume(newVolume:Number):void{    }        public function checkForPlayability(newVolume:Number):void    {    	if(this.isPlayable){        var transform:SoundTransform = _soundChannel.soundTransform;        transform.volume = newVolume;        _soundChannel.soundTransform = transform;      }    }        public function get tracksLoaded():Boolean   { return !(_tracks == null); }    public function get isPlayable():Boolean     { return _soundChannel != null; }    public function get currentTrack():XML       { return (_currentTrackNum != -1) ? getTrack(_currentTrackNum) : null; }    public function get currentTrackNum():uint   { return _currentTrackNum; }    public function get totalTracks():uint       { return _tracks.length(); }    public function get tracks():XMLList         { return _tracks;  }    public function get state():String           { return _state;   }    public function get channel():SoundChannel   { return _soundChannel;   }    public function get status():AudioStatus     { return _status   }    public function get isScrubbing():Boolean    { return (_state == AudioPlayer.SCRUBBING_PAUSED || _state == AudioPlayer.SCRUBBING) ; }    public function get nextTrackNum():uint      { return (_currentTrackNum  == this.tracks.length() -1) ? 0 : _currentTrackNum + 1; }    public function get prevTrackNum():uint      { return (_currentTrackNum  == 0) ? this.tracks.length() -1 : _currentTrackNum - 1; }    public function get canPlayNext():Boolean    { return (this.REPEAT || this.nextTrackNum !=0);                     }    public function get canPlayPrev():Boolean    { return (this.REPEAT || this.prevTrackNum != this.tracks.length() - 1);  }    private function getTrack(trackNum:uint):XML { return _tracks[trackNum]; }        public function areAllDead():Boolean    {      return _tracks.length() == _tracks.(hasOwnProperty("@isDead")).length();    }        private function load(location:String):Sound    {       if(!location || location == "") return null;      //      var r:URLRequest = new URLRequest(location);//      var s:URLStream = new URLStream();//      s.load(r);//      s.addEventListener(ProgressEvent.PROGRESS, progressHandler);            var sound:Sound = new Sound();      sound.addEventListener(Event.SOUND_COMPLETE, onSoundComplete);      sound.addEventListener(IOErrorEvent.IO_ERROR, onIOError);      sound.addEventListener(Event.OPEN, bounceEvent);      var request:URLRequest = new URLRequest(location);      request.contentType = "audio/mpeg";      sound.load(request);      _currentPosition = 0;            return sound;    }    //    private function progressHandler(event:Event):void {//      Util.d("progressHandler: " + event.target.readByte());//    }        private function startPositionTimer():void    {      _positionUpdateTimer = new Timer(POSITION_UPDATE_INTERVAL);      _positionUpdateTimer.addEventListener(TimerEvent.TIMER, updatePosition);      _positionUpdateTimer.start();    }        private function stopPositionTimer():void    {      _positionUpdateTimer.stop();      _positionUpdateTimer.removeEventListener(TimerEvent.TIMER, updatePosition);    }        private function updatePosition(event:Event):void    {      var estimatedLength:int = Math.ceil(_sound.length / (_sound.bytesLoaded / _sound.bytesTotal));      var playbackPercent:uint = Math.round(100 * (_soundChannel.position / estimatedLength));            var currentSeconds:uint = _positionUpdateTimer.currentCount * POSITION_UPDATE_INTERVAL;            if(_sound.bytesTotal < 10000 && (currentSeconds == 7000 || (currentSeconds == 2000 && this.currentTrack.@isDead == true)) ){        this.markDead();      }else if( (_sound.bytesTotal > 10000 ||                 _positionUpdateTimer.currentCount * POSITION_UPDATE_INTERVAL == 7000 + POSITION_UPDATE_INTERVAL) && this.currentTrack &&                this.currentTrack.@isTested != true){      	this.dispatchAudioEvent(AudioEvent.ALIVE_TRACK);      }      var pos:uint = (_state == AudioPlayer.PAUSED || _state == AudioPlayer.SCRUBBING) ? _currentPosition : _soundChannel.position;      _status = new AudioStatus(pos, _sound.length, _sound.bytesLoaded, _sound.bytesTotal, this._currentTrackNum, this.totalTracks);      if(this.currentTrack){      	this.dispatchAudioEvent(AudioEvent.STATUS, _status);      }           //Util.d(_status.toString());    }            private function bounceEvent(event:Event):void    {      var cloneEvent:Event = event.clone();      dispatchEvent(cloneEvent);    }        private function onSoundComplete(event:Event):void    {      this.stop();      this.dispatchAudioEvent(AudioEvent.TRACK_COMPLETE);      if(this.AUTONEXT && this.canPlayNext && this.state != AudioPlayer.PAUSED ) {        this.next();      }else{        this.dispatchAudioEvent(AudioEvent.STOPPED);      }    }        private function onIOError(event:IOErrorEvent):void    {      Util.d("AudioPlayer:/onIOError: " + event.text);      // this.stop();      // this.dispatchAudioEvent(AudioEvent.DEAD_TRACK);      markDead();    }        private function markDead():void    {		 	this.stop();      this.dispatchAudioEvent(AudioEvent.DEAD_TRACK);    }        private function processResult(event:Event):void    {      Util.d("## ##");      var loader:URLLoader = URLLoader(event.target);      this.play(this.currentTrackNum);    }        private function handleSecurityError(event:SecurityErrorEvent):void     {      Util.d("## call failed: " +  event);      this.dispatchAudioEvent(AudioEvent.DEAD_TRACK);    }        private function handleIOErrorEvent(event:IOErrorEvent):void    {      Util.d("## call failed: " +  event);      this.dispatchAudioEvent(AudioEvent.DEAD_TRACK);    }                protected function dispatchAudioEvent(type:String, pStatus:AudioStatus = null):void    {      (pStatus == null) ? this.dispatchEvent(new AudioEvent(type, this.currentTrack)) :                          this.dispatchEvent(new AudioEvent(type, this.currentTrack, pStatus));    }  }}